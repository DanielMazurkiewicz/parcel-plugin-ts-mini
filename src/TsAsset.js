"use strict";

const { Asset } = require('parcel-bundler');
const localRequire = require('parcel-bundler/src/utils/localRequire');
const isAccessedVarChanged = require('parcel-bundler/src/utils/isAccessedVarChanged');
const writeback = require('./writeback');
const change = require('./change');
const { writeFileSync } = require('fs');

class TsAsset extends Asset {
  constructor(name, options) {
    super(name, options);
    this.$ = {name, options}
    this.type = 'js';
    this.cacheData.env = {};
  }

  shouldInvalidate(cacheData) {
    return isAccessedVarChanged(cacheData);
  }

  async generate() {
    // require typescript, installed locally in the app
    let typescript = await localRequire('typescript', this.name);
    let transpilerOptions = {
      compilerOptions: {
        module: this.options.scopeHoist
          ? typescript.ModuleKind.ESNext
          : typescript.ModuleKind.CommonJS,
        jsx: typescript.JsxEmit.Preserve,

        // it brings the generated output from TypeScript closer to that generated by Babel
        // see https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html
        esModuleInterop: true
      },
      fileName: this.relativeName
    };

    let tsconfig = await this.getConfig(['tsconfig.json']);

    // Overwrite default if config is found
    if (tsconfig) {
      transpilerOptions.compilerOptions = Object.assign(
        transpilerOptions.compilerOptions,
        tsconfig.compilerOptions
      );
    }
    transpilerOptions.compilerOptions.noEmit = false;
    transpilerOptions.compilerOptions.sourceMap = this.options.sourceMaps;


    // Prepare new code content
    const writebackCode = writeback(this.contents, typescript, this.name, this.options);
    // console.log(writebackCode);

    if (writebackCode !== this.contents) {
      writeFileSync(this.name, writebackCode);
    }
    // this.$.options
    // this.$.options.env


    const changedCode = change(writebackCode, typescript, this.name, this.options);

    // Transpile Module using TypeScript and parse result as ast format through babylon
    let transpiled = typescript.transpileModule(
      changedCode,
      transpilerOptions
    );
    let sourceMap = transpiled.sourceMapText;

    if (sourceMap) {
      sourceMap = JSON.parse(sourceMap);
      sourceMap.sources = [this.relativeName];
      sourceMap.sourcesContent = [changedCode];

      // Remove the source map URL
      let content = transpiled.outputText;
      transpiled.outputText = content.substring(
        0,
        content.lastIndexOf('//# sourceMappingURL')
      );
    }

    return [
      {
        type: 'js',
        value: transpiled.outputText,
        map: sourceMap
      }
    ];
  }
}

module.exports = TsAsset;